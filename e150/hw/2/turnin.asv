close all
clear
clc

% From Table 1
dt = .2; % s. time step size
t_f = 60; % s. maximum task time
time_steps = 0:dt:t_f; % time step iterator
num_steps = length(time_steps); % time_step index iterator

% From Table 2
N_m = 5; % number of initial agents


F_t = {}; % N. ith agent total force vector




% From Table 3
children = 6; % number of designs generated by breeding
parents = 6; % number of designs kept from last generation
S = 20; % designs per generation
G = 100; % max number of generations


% derived variables
F_tot = {}; % total force vector

% initial positions of agents
% each col is the position of the ith agent
r_i = cell(1, num_steps);
r_i{1}(1, :) = linspace(-150, -110, N_m);
r_i{1}(2, :) = linspace(-10, 10, N_m);
r_i{1}(3, :) = linspace(-10, 10, N_m);
r_i_init = r_i; % create init variable to reset for each run without changing initial conditions

% initial positions of obstacles
% each col is the position of the jth obstacle
N_o = 6;
O_j(1:2, :) = -100 + 200 .* rand(2, N_o);
O_j(3, :) = -10 + 20 .* rand(1, N_o);
O_j_init = O_j; % create init variable to reset for each run without changing initial conditions

% initial positions of targets
% each col is the position of the jth target
N_t = 7;
T_j(1:2, :) = -100 + 200 .* rand(2, N_t);
T_j(3, :) = -10 + 20 .* rand(1, N_t);
T_j_init = T_j; % create init variable to reset for each run without changing initial conditions

%% Simulation
fprintf("Starting UAV swarm simulation...\n");
tic;

% Static variables
% From Table 1
A_i = 1; % m^2. agent characteristic area
C_di = .25; % agent coefficient of drag
m_i = 10; % kg. agent mass
magF_pi = 200; % N, prop force magnitude
v_a = 0; %m/s. air velocity
p_a = 1.225; % kg/m^3. air density
dt = .2; % s. time step size
t_f = 60; % s. maximum task time
time_steps = 0:dt:t_f; % time step iterator
num_steps = length(time_steps); % time_step index iterator

% From Table 2
agent_sight = 5; % m. target mapping distance
crash_range = 2; % m. agent collision distance

% From Table 3
w_1 = 70; % weight of mapping in net cost
w_2 = 10; % weight of time usage in net cost
w_3 = 20; % weight of agent losses in net cost

% From Table 1
% Reset drone state to initial
n_i = {}; % ith agent prop force direction unit vector (eqn 25)

% Variables to be reset at the start of each call to the function
v_i = cell(1, num_steps); % m/s. ith agent velocity
v_i{1} = zeros(3, N_m);

F_di = cell(1, num_steps); % N. ith agent drag force vector
F_di{1} = zeros(3, N_m);

F_pi = cell(1, num_steps); % N. ith agent prop force vector (eqn 6)
F_pi{1} = zeros(3, N_m);

a_i = cell(1, num_steps); % m/s^2. ith agent acceleration

dmt_ij = cell(1, num_steps);
nmt_ij
nmt_bar_ij

dmm_ij
nmm_ij
nmm_bar_ij

dmo_ij


r_i = r_i_init; % reset to init variable (lose data for that run)
O_j = O_j_init;
T_j = T_j_init;

w_t1 = 1;
w_t2 = 2;
a_1 = 1;
a_2 = 2;
w_o1 = 1;
w_o2 = 2;
b_1 = 1;
b_2 = 2;
w_m1 = 1;
w_m2 = 2;
c_1 = 1;
c_2 = 2;
W_mt = 1;
W_mo = 2;
W_mm = 3;

map_done = 0;
all_agents_dead = 0;
t = 1;

% tic;
while ( t < num_steps )
    % myProgressBar(toc, n, num_steps);
    i = 1;
    while ( i <= size(r_i{t}, 2) )
        agents_dead = 0;
        % Agent target interaction
        j = 1;
        while ( j <= size(T_j, 2) )
            dmt_ij{t}(j, i) = norm( r_i{t}(:, i) - T_j(:, j) ); % euclidean distance between ith agent and jth target
            if dmt_ij{t}(j, i) <= agent_sight % if the agent can see the target
                T_j(:, j) = []; % remove that target from the group of targets
            else
                nmt_ij{t}{j, i} = ( T_j(:, j) - r_i{t}(:, i) ) ./ ( norm(T_j(:, j) - r_i{t}(:, i)) ); % unit vector between ith agent and jth target
                nmt_bar_ij{t}{j, i} = ( w_t1 .* exp(-a_1.*dmt_ij{t}(j, i)) - w_t2 .* exp(-a_2.*dmt_ij{t}(j, i)) ) .* nmt_ij{t}{j, i}; % interaction vector between ith agent and jth target
                j = j + 1;
            end
        end
        
        % check if all targets are mapped
        if size(T_j, 2) == 0
            map_done = 1;
            break;
        end
        
        % Agent agent interaction
        j = 1;
        while ( j <= size(r_i{t}, 2) )
            if i == j
                nmm_bar_ij{t}{j, i} = [0; 0; 0];
                j = j + 1;
            else
                dmm_ij{t}(j, i) = norm( r_i{t}(:, i) - r_i{t}(:, j) ); % euclidean distance between ith agent and jth agent
                if dmm_ij{t}(j, i) <= crash_range
                    if i > j
                        r_i{t}(:, i) = [];
                        v_i{t}(:, i) = [];
                        r_i{t}(:, j) = [];
                        v_i{t}(:, j) = [];
                    else
                        r_i{t}(:, j) = [];
                        v_i{t}(:, j) = [];
                        r_i{t}(:, i) = [];
                        v_i{t}(:, i) = [];
                    end
                    agents_dead = 2;
                    break;
                else
                    nmm_ij{t}{j, i} = ( r_i{t}(:, j) - r_i{t}(:, i) ) ./ ( norm(r_i{t}(:, j) - r_i{t}(:, i)) ); % unit vector between ith agent and jth agent
                    nmm_bar_ij{t}{j, i} = ( w_m1 .* exp(-c_1.*dmm_ij{t}(j, i)) - w_m2 .* exp(-c_2.*dmm_ij{t}(j, i)) ) .* nmm_ij{t}{j, i}; % interaction vector between ith agent and jth agent
                    j = j + 1;
                end
            end
        end
        
        if agents_dead == 2
            continue;;
        end
        
        % Agent obstacle interaction
        j = 1;
        while ( j <= size(O_j, 2) )
            dmo_ij{t}(j, i) = norm( r_i{t}(:, i) - O_j(:, j) ); % euclidean distance between ith agent and jth obstacle
            if dmo_ij{t}(j, i) <= crash_range
                r_i{t}(:, i) = [];
                v_i{t}(:, i) = [];
                agents_dead = 1;
                break;
            else
                nmo_ij{t}{j, i} = ( O_j(:, j) - r_i{t}(:, i) ) ./ ( norm(O_j(:, j) - r_i{t}(:, i)) ); % unit vector between ith agent and jth obstacle
                nmo_bar_ij{t}{j, i} = ( w_o1 .* exp(-b_1.*dmo_ij{t}(j, i)) - w_o2 .* exp(-b_2.*dmo_ij{t}(j, i)) ) .* nmo_ij{t}{j, i}; % interaction vector between ith agent and jth obstacle
                j = j + 1;
            end
        end
        
        if agents_dead == 1
            continue;;
        end
        
        % check if any agents are still alive
        if size(r_i{t}, 2) == 0
            all_agents_dead = 1;
            break;
        end
        
        % Each col is the interaction vector of the ith agent
        % Agent target total interaction vector
        Nmt_i{t}(:, i) = sum( [nmt_bar_ij{t}{:}], 2 );
        
        % Agent obstacle total interaction vector
        Nmo_i{t}(:, i) = sum( [nmo_bar_ij{t}{:}], 2 );
        
        % Agent agent total interaction vector
        Nmm_i{t}(:, i) = sum( [nmm_bar_ij{t}{:}], 2 );
        
        % Total interaction for ith agent
        Ntot_i{t}(:, i) = W_mt .* Nmt_i{t}(:, i) + W_mo .* Nmo_i{t}(:, i) + W_mm .* Nmm_i{t}(:, i);
        
        % Propulsive force direction vector
        n_i{t}(:, i) = Ntot_i{t}(:, i) ./ norm(Ntot_i{t}(:, i));
        
        i = i + 1;
    end
    
    % check stop criteria
    if map_done || all_agents_dead
        break;
    end
    
    % Each col is the ith agent
    F_pi{t} = magF_pi .* n_i{t}; % propulsive force on each agent
    F_di{t} = .5 .* p_a .* C_di .* A_i .* norm(v_a - v_i{t}) .* (v_a - v_i{t}); % drag force on each agent
    F_tot{t} = F_pi{t} + F_di{t}; % sum forces (neglect gravity)
    a_i{t} = F_tot{t} ./ m_i; % calculate current acceleration of each agent
    
    v_i{t+1} = v_i{t} + a_i{t} .* dt; % calculate velocity at next time step
    r_i{t+1} = r_i{t} + v_i{t} .* dt; % calculate position at next time step
    
    t = t + 1;
end

% get final time taken
t_final = time_steps(t);

% Create cost function (eqn 27)
Mstar = (N_t - size(T_j, 2)) / N_t; % fraction of unmapped targets
Tstar = t_final / t_f; % fraction of used time out of total time
Lstar = (N_m - size(r_i, 2)) / N_m; % fraction of crashed agents out of initial agents
cost = w_1*Mstar + w_2*Tstar + w_3*Lstar; % cost function

toc;
fprintf("Done with UAV swarm simulation!\n")
