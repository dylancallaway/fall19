close all
clear
clc

% From Table 1
dt = .2; % s. time step size
t_f = 60; % s. maximum task time

% From Table 2
N_m = 5; % number of initial agents
N_m_orig = N_m;

% derived variables
time_steps = 0:dt:t_f; % time step iterator
num_steps = length(time_steps); % time_step index iterator
F_t = zeros(3, N_m, num_steps); % N. ith agent total force vector

% From Table 2
agent_sight = 5; % m. target mapping distance
crash_range = 2; % m. agent collision distance
N_o = 6; % number of obstacles
N_o_orig = N_o;
N_t = 7; % number of initial targets
N_t_orig = N_t;
O_j = zeros(3, N_o); % m. jth obstacle position (cols are the jth obstacle) (eqn 10)
T_j = zeros(3, N_t); % m. jth target positon (cols are the jth target) (eqn 10)

% From Table 1
% cols are the state of the ith agent
A_i = 1; % m^2. agent characteristic area
C_di = .25; % agent coefficient of drag
m_i = 10; % kg. agent mass
magF_pi = 200; % N, prop force magnitude
r_i = zeros(3, N_m, num_steps); % m. ith agent position
v_a = 0; %m/s. air velocity
p_a = 1.225; % kg/m^3. air density

% From Table 3
children = 6; % number of designs generated by breeding
parents = 6; % number of designs kept from last generation
S = 20; % designs per generation
G = 100; % max number of generations
% The following 3 variables are in anonymous function cost_fcn
% Lstar. fraction of agents lost (eqn 27)
% Mstar. fraction of targets remaining (eqn 27)
% Tstar. fraction of time used (eqn 27)
w1 = 70; % weight of mapping in net cost
w2 = 10; % weight of time usage in net cost
w3 = 20; % weight of agent losses in net cost

% derivd variables
F_tot = zeros(3, N_m, num_steps); % total force vector

% define cost function and redefine with weights passed in
cost_fcn = @(w1, w2, w3, Mstar, Tstar, Lstar) w1*Mstar + w2*Tstar + w3*Lstar;
cost_fcn = @(Mstar, Tstar, Lstar)cost_fcn(w1, w2, w3, Mstar, Tstar, Lstar);

% initial positions of agents
% each col is the position of the ith agent
r_i(1, :, 1) = linspace(-150, -110, N_m);
r_i(2, :, 1) = linspace(-10, 10, N_m);
r_i(3, :, 1) = linspace(-10, 10, N_m);
r_i_init = r_i; % create init variable to reset for each run without changing initial conditions

% initial positions of obstacles
% each col is the position of the jth obstacle
O_j(1:2, :) = -100 + 200 .* rand(2, N_o);
O_j(3, :) = -10 + 20 .* rand(1, N_o);
O_j_init = O_j; % create init variable to reset for each run without changing initial conditions

% initial positions of targets
% each col is the position of the jth target
T_j(1:2, :) = -100 + 200 .* rand(2, N_t);
T_j(3, :) = -10 + 20 .* rand(1, N_t);
T_j_init = T_j; % create init variable to reset for each run without changing initial conditions

%% Simulation
fprintf("Starting UAV swarm simulation...\n");
tic;
% From Table 1
% Reset drone state to initial
F_pi = zeros(3, N_m, num_steps); % N. ith agent prop force vector (eqn 6)
n_i = zeros(3, N_m, num_steps); % ith agent prop force direction unit vector (eqn 25)
F_di = zeros(3, N_m, num_steps); % N. ith agent drag force vector
v_i = zeros(3, N_m, num_steps); % m/s. ith agent velocity
a_i = zeros(3, N_m, num_steps); % m/s^2. ith agent acceleration
r_i = r_i_init; % reset to init variable (lose data for that run)
O_j = O_j_init;
T_j = T_j_init;
w_t1 = 1;
w_t2 = 2;
a_1 = 1;
a_2 = 2;
w_o1 = 1;
w_o2 = 2;
b_1 = 1;
b_2 = 2;
w_m1 = 1;
w_m2 = 2;
c_1 = 1;
c_2 = 2;
W_mt = 1;
W_mo = 2;
W_mm = 3;
dmt_ij = zeros(N_t, N_m, num_steps);
dmo_ij = zeros(N_o, N_m, num_steps);
dmm_ij = zeros(N_m, N_m, num_steps);
nmt_ij = cell(N_t, N_m, num_steps);
nmt_bar_ij = cell(N_t, N_m, num_steps);
nmo_ij = cell(N_o, N_m, num_steps);
nmo_bar_ij = cell(N_o, N_m, num_steps);
nmm_ij = cell(N_m, N_m, num_steps);
nmm_bar_ij = cell(N_m, N_m, num_steps);
Nmt_i = zeros(3, N_m, num_steps);
Nmo_i = zeros(3, N_m, num_steps);
Nmm_i = zeros(3, N_m, num_steps);
Ntot_i = zeros(3, N_m, num_steps);
% I preallocated all of these and it takes the same amount of time -_-

% tic;
for t = 1:num_steps
    % myProgressBar(toc, n, num_steps);
    
    for i = 1:N_m
        % Agent target interaction
        for j = 1:N_t
            dmt_ij(j, i, t) = norm( r_i(:, i, t) - T_j(:, j) ); % euclidean distance between ith agent and jth target
            nmt_ij{j, i, t} = ( T_j(:, j) - r_i(:, i, t) ) ./ ( norm(T_j(:, j) - r_i(:, i, t)) ); % unit vector between ith agent and jth target
            nmt_bar_ij{j, i, t} = ( w_t1 .* exp(-a_1.*dmt_ij(j, i, t)) - w_t2 .* exp(-a_2.*dmt_ij(j, i, t)) ) .* nmt_ij{j, i, t}; % interaction vector between ith agent and jth target
        end
        
        % Agent obstacle interaction
        for j = 1:N_o
            dmo_ij(j, i, t) = norm( r_i(:, i, t) - O_j(:, j) ); % euclidean distance between ith agent and jth obstacle
            nmo_ij{j, i, t} = ( O_j(:, j) - r_i(:, i, t) ) ./ ( norm(O_j(:, j) - r_i(:, i, t)) ); % unit vector between ith agent and jth obstacle
            nmo_bar_ij{j, i, t} = ( w_o1 .* exp(-b_1.*dmo_ij(j, i, t)) - w_o2 .* exp(-b_2.*dmo_ij(j, i, t)) ) .* nmo_ij{j, i, t}; % interaction vector between ith agent and jth obstacle
        end
        
        % Agent agent interaction
        for j = 1:N_m
            if i == j
                nmm_bar_ij{j, i, t} = [0; 0; 0];
            else
                dmm_ij(j, i, t) = norm( r_i(:, i, t) - r_i(:, j, t) ); % euclidean distance between ith agent and jth agent
                nmm_ij{j, i, t} = ( r_i(:, j, t) - r_i(:, i, t) ) ./ ( norm(r_i(:, j, t) - r_i(:, i, t)) ); % unit vector between ith agent and jth agent
                nmm_bar_ij{j, i, t} = ( w_m1 .* exp(-c_1.*dmm_ij(j, i, t)) - w_m2 .* exp(-c_2.*dmm_ij(j, i, t)) ) .* nmm_ij{j, i, t}; % interaction vector between ith agent and jth agent
            end
        end
        
        % Each col is the interaction vector of the ith agent
        % Agent target total interaction vector
        Nmt_i(:, i, t) = sum( [nmt_bar_ij{:, i, t}], 2 );
        
        % Agent obstacle total interaction vector
        Nmo_i(:, i, t) = sum( [nmo_bar_ij{:, i, t}], 2 );
        
        % Agent agent total interaction vector
        Nmm_i(:, i, t) = sum( [nmm_bar_ij{:, i, t}], 2 );
        
        % Total interaction for ith agent
        Ntot_i(:, i, t) = W_mt .* Nmt_i(:, i, t) + W_mo .* Nmo_i(:, i, t) + W_mm .* Nmm_i(:, i, t);
        
        % Propulsive force direction vector
        n_i(:, i, t+1) = Ntot_i(:, i, t) ./ norm(Ntot_i(:, i, t));
    end
    
    % Each col is the ith agent
    F_pi(:, :, t+1) = magF_pi .* n_i(:, :, t+1); % propulsive force on each agent
    F_di(:, :, t) = .5 .* p_a .* C_di .* A_i .* norm(v_a - v_i(:, :, t)) .* (v_a - v_i(:, :, t)); % drag force on each agent
    F_tot(:, :, t) = F_pi(:, :, t) + F_di(:, :, t); % sum forces (neglect gravity)
    a_i(:, :, t) = F_tot(:, :, t) ./ m_i; % calculate current acceleration of each agent
    
    v_i(:, :, t+1) = v_i(:, :, t) + a_i(:, :, t) .* dt; % calculate velocity at next time step
    r_i(:, :, t+1) = r_i(:, :, t) + v_i(:, :, t) .* dt; % calculate position at next time step
end

Mstar = (N_m_orig - N_m) / N_m_orig; % fraction of unmapped targets
Tstar = t_final / 

% 9/22 LEFT OFF
% Calculating propulsve vector correctly
% TODO add target/obstacle/crash interaction stuff
% Like if within range then get rid of obstacle, etc.

toc;
fprintf("Done with UAV swarm simulation!")