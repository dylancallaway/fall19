function [cost] = myUAV(r_i, O_j, T_j, W_mt, W_mo, W_mm, w_t1, w_t2, w_o1, w_o2, w_m1, w_m2, a_1, a_2, b_1, b_2, c_1, c_2)
% Simulation
fprintf("Starting UAV swarm simulation...\n");
tic;

% Static variables
% From Table 1
A_i = 1; % m^2. agent characteristic area
C_di = .25; % agent coefficient of drag
m_i = 10; % kg. agent mass
magF_pi = 200; % N, prop force magnitude
v_a = 0; %m/s. air velocity
p_a = 1.225; % kg/m^3. air density
dt = .2; % s. time step size
t_f = 60; % s. maximum task time
time_steps = 0:dt:t_f; % time step iterator
num_steps = length(time_steps); % time_step index iterator

% From Table 2
N_m = 15;
N_t = 100;
agent_sight = 5; % m. target mapping distance
crash_range = 2; % m. agent collision distance

% From Table 3
w_1 = 70; % weight of mapping in net cost
w_2 = 10; % weight of time usage in net cost
w_3 = 20; % weight of agent losses in net cost

% Variables to be reset at the start of each call to the function
v_i = cell(1, num_steps); % m/s. ith agent velocity
v_i{1} = zeros(3, N_m);

F_di = cell(1, num_steps); % N. ith agent drag force vector
F_di{1} = zeros(3, N_m);

F_pi = cell(1, num_steps); % N. ith agent prop force vector (eqn 6)
F_pi{1} = zeros(3, N_m);

F_t =  cell(1, num_steps); % N. ith agent total force vector
a_i = cell(1, num_steps); % m/s^2. ith agent acceleration

dmt_ij = cell(1, num_steps);
nmt_ij = cell(1, num_steps);
nmt_bar_ij = cell(1, num_steps);

dmm_ij = cell(1, num_steps);
nmm_ij = cell(1, num_steps);
nmm_bar_ij = cell(1, num_steps);

dmo_ij = cell(1, num_steps);
nmo_ij = cell(1, num_steps);
nmo_bar_ij = cell(1, num_steps);

Nmt_i = cell(1, num_steps);
Nmo_i = cell(1, num_steps);
Nmm_i = cell(1, num_steps);
Ntot_i = cell(1, num_steps);
n_i = cell(1, num_steps);

map_done = 0;
all_agents_dead = 0;
t = 1;

while ( t < num_steps )
    % myProgressBar(toc, n, num_steps);
    i = 1;
    while ( i <= size(r_i, 2) )
        agents_dead = 0;
        % Agent target interaction
        j = 1;
        while ( j <= size(T_j, 2) )
            dmt_ij(j, i) = norm( r_i(:, i) - T_j(:, j) ); % euclidean distance between ith agent and jth target
            if dmt_ij(j, i) <= agent_sight % if the agent can see the target
                T_j(:, j) = []; % remove that target from the group of targets
            else
                nmt_ij{j, i} = ( T_j(:, j) - r_i(:, i) ) ./ ( norm(T_j(:, j) - r_i(:, i)) ); % unit vector between ith agent and jth target
                nmt_bar_ij{j, i} = ( w_t1 .* exp(-a_1.*dmt_ij(j, i)) - w_t2 .* exp(-a_2.*dmt_ij(j, i)) ) .* nmt_ij{j, i}; % interaction vector between ith agent and jth target
                j = j + 1;
            end
        end
        
        % check if all targets are mapped
        if size(T_j, 2) == 0
            map_done = 1;
            break;
        end
        
        % Agent agent interaction
        j = 1;
        while ( j <= size(r_i, 2) )
            if i == j
                nmm_bar_ij{j, i} = [0; 0; 0];
                j = j + 1;
            else
                dmm_ij(j, i) = norm( r_i(:, i) - r_i(:, j) ); % euclidean distance between ith agent and jth agent
                if dmm_ij(j, i) <= crash_range
                    if i > j
                        r_i(:, i) = [];
                        v_i(:, i) = [];
                        r_i(:, j) = [];
                        v_i(:, j) = [];
                    else
                        r_i(:, j) = [];
                        v_i(:, j) = [];
                        r_i(:, i) = [];
                        v_i(:, i) = [];
                    end
                    agents_dead = 2;
                    break;
                else
                    nmm_ij{j, i} = ( r_i(:, j) - r_i(:, i) ) ./ ( norm(r_i(:, j) - r_i(:, i)) ); % unit vector between ith agent and jth agent
                    nmm_bar_ij{t}{j, i} = ( w_m1 .* exp(-c_1.*dmm_ij(j, i)) - w_m2 .* exp(-c_2.*dmm_ij(j, i)) ) .* nmm_ij{j, i}; % interaction vector between ith agent and jth agent
                    j = j + 1;
                end
            end
        end
        
        if agents_dead == 2
            continue;
        end
        
        % Agent obstacle interaction
        j = 1;
        while ( j <= size(O_j, 2) )
            dmo_ij(j, i) = norm( r_i(:, i) - O_j(:, j) ); % euclidean distance between ith agent and jth obstacle
            if dmo_ij(j, i) <= crash_range
                r_i(:, i) = [];
                v_i(:, i) = [];
                agents_dead = 1;
                break;
            else
                nmo_ij{j, i} = ( O_j(:, j) - r_i(:, i) ) ./ ( norm(O_j(:, j) - r_i(:, i)) ); % unit vector between ith agent and jth obstacle
                nmo_bar_ij{j, i} = ( w_o1 .* exp(-b_1.*dmo_ij(j, i)) - w_o2 .* exp(-b_2.*dmo_ij(j, i)) ) .* nmo_ij{j, i}; % interaction vector between ith agent and jth obstacle
                j = j + 1;
            end
        end
        
        if agents_dead == 1
            continue;
        end
        
        % check if any agents are still alive
        if size(r_i, 2) == 0
            all_agents_dead = 1;
            break;
        end
        
        % Each col is the interaction vector of the ith agent
        % Agent target total interaction vector
        Nmt_i(:, i) = sum( [nmt_bar_ij{:}], 2 );
        
        % Agent obstacle total interaction vector
        Nmo_i(:, i) = sum( [nmo_bar_ij{:}], 2 );
        
        % Agent agent total interaction vector
        Nmm_i(:, i) = sum( [nmm_bar_ij{:}], 2 );
        
        % Total interaction for ith agent
        Ntot_i(:, i) = W_mt .* Nmt_i(:, i) + W_mo .* Nmo_i(:, i) + W_mm .* Nmm_i(:, i);
        
        % Propulsive force direction vector
        n_i(:, i) = Ntot_i(:, i) ./ norm(Ntot_i(:, i));
        
        i = i + 1;
    end
    
    % check stop criteria
    if map_done || all_agents_dead
        break;
    end
    
    % Each col is the ith agent
    F_pi = magF_pi .* n_i; % propulsive force on each agent
    F_di = .5 .* p_a .* C_di .* A_i .* norm(v_a - v_i) .* (v_a - v_i); % drag force on each agent
    F_t = F_pi + F_di; % sum forces (neglect gravity)
    a_i{t} = F_t{ ./ m_i; % calculate current acceleration of each agent
    
    v_i{t+1} = v_i{t} + a_i{t} .* dt; % calculate velocity at next time step
    r_i{t+1} = r_i{t} + v_i{t} .* dt; % calculate position at next time step
    
    t = t + 1;
end

% get final time taken
t_final = time_steps(t);

% Create cost function (eqn 27)
Mstar = (N_t - size(T_j, 2)) / N_t; % fraction of unmapped targets
Tstar = t_final / t_f; % fraction of used time out of total time
Lstar = (N_m - size(r_i{t}, 2)) / N_m; % fraction of crashed agents out of initial agents
cost = w_1*Mstar + w_2*Tstar + w_3*Lstar; % cost function

toc;
fprintf("Done with UAV swarm simulation!\n")
end

